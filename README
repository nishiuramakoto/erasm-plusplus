Copyright 2010,2011,2012 Makoto Nishiura.

This directory tree holds version 0.1 of ERASM++, Embedded Run-time ASseMbler
in C++, a library for runtime code generation,inspection,and meta-programming.

See INSTALL for system requirements and installation instructions.

Contents
1. Introduction
2. ERASM++
 2.1 Overview
 2.2 Basic Usage
 2.3 Syntax
 2.4 Performance
 2.5 Applications
 2.6 Limitations
3. Generic Instruction Decoder
 3.1 Overview
 3.2 Basic Usage
 3.3 Performance
4. MetaPrelude
 4.1 Overview
5. License 

1. Intruduction

This is a collection of libraries for run-time code inspection and code 
generation. They were conceived as the first non-trivial Embedded Domain 
Specific Language (EDSL) application of my lazy meta-programming library,
MetaPrelude, which is also included in this distribution. The emphasis has
been on ease-of-use, type-safety,genericity,flexibility,and (run-time) 
performance at the sacrifice of increased compile-time resource usage. I 
presume this increased resource usage may not be essential and will disappear
in the long run, as the equivalent Haskell program, which runs orders of
magnitude faster than the original meta-program, clearly shows. 

Having exprienced the power of meta-programming (static type level computing)
myself, I now guess the combination of an imperative language and a type-level
lazy functional language (preferably itself strongly-typed,resulting in a
three (or more) layered language as a whole) might be a candidate for the
next programming language paradigm. But not in the current form of ad-hoc
meta-programming as we see in the case of C++ -- it is just too slow and its
syntax and semantics don't look very pretty. Our MetaPrelude is an attempt to
make it at least a bit prettier by immitating existing state-of-the-art
functional language,and our code generation EDSL is an attempt to demonstrate
its general usefulness. Only the user can measure their successes,and I am
always eager to hear your feedback. Thanks!

Makoto Nishiura (nishiuramakoto@gmail.com)
Jan 11,2012 

2. ERASM++

2.1 Overview

ERASM++ is an Embedded Domain Specific Language(EDSL) in C++ for run-time
code generation.Its main strengths are very close syntactical similarity
with the real assembly language, near full standard-conformance (see below
for exceptions) , complete compile-time syntax checking,and the ability to
produce very high quality code.Current support includes Intel x64/x86
architecture only.

2.2 Basic Usage

32-bit case

First,create a file called demo86.cpp with the following contents:

<CODE>
#include <erasm/x86_addr32_data32.hpp>
#include <iostream>

typedef int (*func_type) (int);

int main(int argc,char**argv)
{
   using namespace std;
   using namespace erasm::x86;
   using namespace erasm::x86::addr32;
   using namespace erasm::x86::addr32::data32;

   byte_t buf[100];
   byte_t *p = buf;
   int32_t x = 2;

   p += mov(p,eax,dword_ptr[esp+4]);
   p += add(p,eax,x);
   p += ret(p);

   func_type f = (func_type)buf;   
   int len = p - buf;

   cout  << "code length=" << len << endl
	 << "result=" << f(argc) << endl;
   return 0;
}
</CODE>

Then,run the following commands:
# g++ -DNDEBUG demo86.cpp -lerasm86 -o demo86
# ./demo86
# ./demo86 a b

Provided the stack is executable in your operating system by default,it
will print the numbers 3 and 5.

64-bit case

First,create a file called demo64.cpp with the following contents:

<CODE>
#include <erasm/x64_addr64_data32.hpp>
#include <iostream>

typedef int (*pf_t) (int);

int main(int argc,char**argv)
{
   using namespace std;
   using namespace erasm::x64;
   using namespace erasm::x64::addr64;
   using namespace erasm::x64::addr64::data32;

   byte_t buf[100];
   byte_t *p = buf;
   int32_t x = 2;

   p += mov(p,rax,dword_ptr[rsp+8]);
   p += add(p,rax,x);
   p += ret(p);

   pf_t f = (pf_t)buf;   
   int len = p - buf;
   cout  << "code length=" << len << endl
	 << "result=" << f(argc) << endl;
   return 0;
}
</CODE>

Then,run the following commands:
# g++ -DNDEBUG demo64.cpp -lerasm64 -o demo64
# ./demo64
# ./demo64 a b

Provided the stack is executable in your operating system by default,it 
will print the numbers 3 and 5.

The namespace erasm::x86::addr32::data32 contains the actual instruction
definitions whose default address and operand sizes are 32-bit. Similarly,
the namespace erasm::x64::addr64::data32 should be used for x64 instructions
whose default address and operand sizes are respectively 64-bit and 32-bit.
Currently we don't support other default address or operand size modes.

TODO:Add instructions for other compilers

2.3 Syntax

In general, the prototype of an instruction is in one of the following forms:

int MNEMONIC(uint8_t* p);
int MNEMONIC(uint8_t* p,OPERAND_TYPE op1);
int MNEMONIC(uint8_t* p,OPERAND_TYPE op1,OPERAND_TYPE op2);
int MNEMONIC(uint8_t* p,OPERAND_TYPE op1,OPERAND_TYPE op2,OPERAND_TYPE op3);

where uint8_t is most likely an alias of unsigned char.(see Boost's stdint 
for the detail.) It is declared in erasm::x64 and erasm::x86 namespaces.

The operational meaning of each instruction is always the same.That is,
it encodes the instruction at the location specified by the first argument(p),
and returns the number of bytes encoded.If the target address is writable,it
is guaranteed that either it succeeds to encode the instruction, or the 
instruction is syntactically ill-formed and the compilation fails.It is
undefined what would happen if the destination address is not writable.In
particular,it never throws a (C++) exception.

MNEMONIC is generally one of the lower-case instruction mnemonics as defined
in the Intel's Instruction Set Reference[2]. There are some exceptions,
though.One is that if the lower-case mnemonic is reserved as a keyword in 
C++.In such a case,we append an underscore to the mnemonic, as in 'int_'. 
Additionally,some instructions are ambiguous and cannot be fully specified
solely by the combination of mnemonic and operand types. In such a case, 
we resort to some ad-hoc case-by-case disambiguation schemes such as:
  
 p += rep_movs(p,byte_ptr[rdi],byte_ptr[rsi]);
 p += rexw_rep_movs(p,byte_ptr[rdi],byte_ptr[rsi]);

Here,rep_movs uses ecx as the count register,while rexw_rep_movs uses rcx.
We are searching for less ad-hoc disambiguation methods,but we would also
like the form of those instructions to be directly guessable from the Intel's
manual.

An operand of the type OPERAND_TYPE is generally what your common sense as an
assembly programmer tells you.Here we just list exceptions.

 * The scale coefficient of an index register (e.g. _2 of [edx + _2 * ecx])
   must be specified with the static constants _1,_2,etc. This inconvenience 
   results from the need to compute the necessary data statically,and will
   not change.

 * A memory reference is specified with,say,dword_ptr instead of DWORD PTR, 
   as in dword_ptr[rdi]. You can override the segment of those pointer 
   place-holders, as in byte_ptr.es[edi]. 

 * A displacement of an effective address is specified either with the 
   built-in integers such as int8_t,int16_t,or by small static constants  
   such as _1,_2,etc. These static constants are quite handy when you want
   to say,for example, [rax+(imm8_t)0x2]. This can be rewritten as [rax+_2],
   avoiding  the three bytes overhead of using the 32-bit displacement.

 * It would have been more interesting if an effective address could be an
   arbitrary polynomial of registers with integer coefficients.Then all the 
   power of type level static computing would have been employed. Since this
   is not the case,only the most obvious forms of expressions are supported.

Please see intel's Instruction Set Reference[2] for instruction definitions.

For the examples of valid instructions,see

  src/erasm/x64_assembler_manual_test.cpp
  src/erasm/x64_assembler_auto_test.cpp
  src/erasm/x86_assembler_manual_test.cpp
  src/erasm/x86_assembler_auto_test.cpp

For the examples of ill-formed instructions,see

  src/erasm/x64_assembler_illegal_code.cpp
  src/erasm/x86_assembler_illegal_code.cpp.


2.4 Performance

There are strong arguments against introducing C++ code into the operating
system kernel spaces[5][6].Our view is that, with the systematic use of
type-level computing techniques and careful avoidance of dynamic dispatching,
it is sometimes possible to produce very high-quality code that can be an
order of magnitude faster than the corresponding C code while at the same time
much more user-friendly and perfectly safe to use in the kernel space.

Let us give an example.

g++ 4.6.1 compiles (with the option -O3) the following code

<CODE>
extern "C" int code_test(code_ptr p)
{ return adc(p ,cl,byte_ptr [eax+ebp*_4+12345678]);  }
</CODE>

to

<CODE>
_code_test:
	sub	esp, 32
	mov	eax, DWORD PTR [esp+36]
	mov	BYTE PTR [esp+5], -88
	mov	DWORD PTR [esp+6], 12345678
	mov	BYTE PTR [esp+4], -116
	mov	BYTE PTR [eax], 103
	mov	BYTE PTR [eax+1], 18
	mov	edx, DWORD PTR [esp+4]
	mov	DWORD PTR [eax+2], edx
	mov	edx, DWORD PTR [esp+8]
	mov	WORD PTR [eax+6], dx
	mov	eax, 8
	add	esp, 32
	ret
</CODE>
provided all of the required functions are inlined(see below).

Although the above code is not the fastest possible(for example,it uses
a partial reference of edx,non-aligned mov,etc.), it possesses the following
very nice properties:

* No branches. 

Conditional or not,branches always consume precious processor resources[4],
so their absence is quite beneficial for performance resons. Furthermore,in
kernel spaces,there is a greater risk that the target address is not
accessible at all (e.g. the corresponding section may have been swapped out
and the code runs in a high priority mode.)
 
* No external references.

This is also a very good property for the similar reasons. See [4] for the
details.

Currently the main ERASM++ encoder functions are all compiled in a seperate
module for the sake of compile-time performance.See 
src/test_asm_performance.cpp for how to inline the required functions.


(To be fair,code written in C could achieve the same performance level by
heavy inlining and/or link-time optimizations as the equivalent C++ code with
static type level computing.However,the essential difference lies in
*partial static functions*.I will not delve in detail here,but I'm safe to
say the ability to reject ill-formed instructions at compile-time can never
be achieved by C based implementations.) 

2.5 Applications

We have implemented a prototypical thread-safe function hook library that
can hook __pascal(WINAPI),__ccall and its variants(C++ methods,Windows COM
methods). It can hook,for example,functions in kernel32.dll,ntdll.dll,or
DirectShow methods.

Another interesting application would be to translate a compiled assembly
source file to equivalent ERASM++ code, and to have the whole or part of the
application be generated at run-time.This could be used to increase the cost
of reverse-engineering the IP-sensitive parts of the program.(However,we have
not implemented labels and back-patching schemes yet.)

2.6 Limitations

By far the biggest limitation of ERASM++ is its compile-time resource usage.
For reasons explained later,the exact compile-time behaviour greatly varies
from one compiler version to another.

For example,while g++-4.5.4 compiles a source file which consists of about
2500 instructions just fine with memory usage ~500MB ,g++-4.6.1 consumes all 
its user-space (~2GB) and eventually gives up.

Another disadvantage of using ERASM++ is its often cryptic error messages.
This is inherently an implementation-dependant problem,and is impossible to 
solve generally.

Current implementation only makes some effort to increase readability for g++.

Here's an example (manually formatted) error message from g++:

<CODE>
cvtpd2pi(p,mm1,xmmword_ptr[rax+ rsp*_2]);
</CODE>
results to 

./erasm/meta_prelude_core.hpp:829:128: error: no type named 'result' in 
'struct erasm::prelude::eval<
   erasm::prelude::if_<
     erasm::prelude::error<
        erasm::x64::Error_ESP_and_RSP_cannot_be_used_as_the_index_register,
        erasm::prelude::Term<erasm::prelude::Int<4>, 
                             erasm::prelude::times<erasm::prelude::Int<2>, 
                                                   erasm::prelude::Int<1> > >,
        erasm::prelude::Term<erasm::prelude::Int<0>, erasm::prelude::Int<1> >,
        void, void>, 
     erasm::x64::PtrRex<erasm::x64::XmmWord>, 
     erasm::x64::PtrNoRex<erasm::x64::XmmWord> > >'

Note the 'Error_ESP_and_RSP_cannot_be_used_as_the_index_register' part above,
which correctly spots the problem.

Unfortunately,Microsoft's cl.exe tries to outsmart our effort and emits
more obscure error messages.

ERASM++ declares and uses static constants _1,_2,etc. in one of its
namespaces. This is potentially problematic as the standard specifies that 
any identifier that begins with an underscore is reserved for the
implementation in the global namespace.

Finally,ERASM++ cannot be fully standard conformant because it must be 
dependent on the platform-specific data representations.Howerver,if the 
implementation does support the platform, there should be no problem 
compiling ERASM++ as long as the compiler is reasonably standard-conformant.


3. Generic Instruction Decoder

3.1 Overview
To be written.

3.2 Basic Usage
To be written.
See erasm_dsm_x86_performance_test.cpp for the basic usage.

3.3 Performance
To be written.
Please run 'make time_dsm86' to see if it's really worth the trouble.

4. MetaPrelude

4.1 Overview
To be written.

5. License

ERASM++ is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

ERASM++ is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with ERASM++; see the file COPYING.  If not see
<http://www.gnu.org/licenses/>. 


Reference

[1] Intel速 64 and IA-32 Architectures Software Developer's Manual Volume 1:
    Basic Architecture.
[2] Intel速 64 and IA-32 Architectures Software Developer's Manual Combined
    Volumes 2A, 2B, and 2C: Instruction Set Reference, A-Z.
[3] Intel速 64 and IA-32 Architectures Software Developer's Manual Combined
    Volumes 3A, 3B, and 3C: System Programming Guide, Parts 1 and 2.
[4] Intel速 64 and IA-32 Architectures Optimization Reference Manual.
[5] http://kerneltrap.org/node/2067 
[6] http://msdn.microsoft.com/en-us/windows/hardware/gg487420
