Copyright 2010,2011,2012 Makoto Nishiura.

This is version 0.1 of ERASM++, Embedded Run-time ASseMbler in C++, 
a library for runtime code generation.

See INSTALL for system requirements and installation instructions.
For the moment,this README is intended to serve as the only documentation
of the library.

Contents
1. ERASM++
 1.1 Overview
 1.2 Basic Usage
 1.3 Syntax
 1.4 Performance
 1.5 Limitations
2. License 

1. ERASM++

1.1 Overview

ERASM++ is an Embedded Domain Specific Language(EDSL) in C++ for run-time
code generation.Its main strengths are very close syntactical similarity
with the real assembly language, complete compile-time syntax checking ,the 
ability to produce very high quality code, and near full standard conformance
(see below for exceptions). Current support includes Intel x86/x86-64
architecture only.

1.2 Basic Usage

32-bit case

First,create a file called demo86.cpp with the following contents:

<CODE>
#include <erasm/x86_addr32_data32.hpp>
#include <iostream>

typedef int (*func_type) (int);

int main(int argc,char**argv)
{
   using namespace std;
   using namespace erasm::x86;
   using namespace erasm::x86::addr32;
   using namespace erasm::x86::addr32::data32;

   byte_t buf[100];
   byte_t *p = buf;
   int32_t x = 2;

   p += mov(p,eax,dword_ptr[esp+4]);
   p += add(p,eax,x);
   p += ret(p);

   func_type f = (func_type)buf;   
   int len = p - buf;

   cout  << "code length=" << len << endl
	 << "result=" << f(argc) << endl;
   return 0;
}
</CODE>

Then,run the following commands:
# g++ -DNDEBUG demo86.cpp -lerasm86 -o demo86
# ./demo86
# ./demo86 a b

Provided the stack is executable in your operating system by default,it
will print the numbers 3 and 5.

64-bit case

First,create a file called demo64.cpp with the following contents:

<CODE>
#include <erasm/x64_addr64_data32.hpp>
#include <iostream>

typedef int (*pf_t) (int);

int main(int argc,char**argv)
{
   using namespace std;
   using namespace erasm::x64;
   using namespace erasm::x64::addr64;
   using namespace erasm::x64::addr64::data32;

   byte_t buf[100];
   byte_t *p = buf;
   int32_t x = 2;

   p += mov(p,rax,dword_ptr[rsp+8]);
   p += add(p,rax,x);
   p += ret(p);

   pf_t f = (pf_t)buf;   
   int len = p - buf;
   cout  << "code length=" << len << endl
	 << "result=" << f(argc) << endl;
   return 0;
}
</CODE>

Then,run the following commands:
# g++ -DNDEBUG demo64.cpp -lerasm64 -o demo64
# ./demo64
# ./demo64 a b

Provided the stack is executable in your operating system by default,it 
will print the numbers 3 and 5.

The namespace erasm::x86::addr32::data32 contains the actual instruction
definitions whose default address and operand sizes are both 32-bit. 
Similarly, the namespace erasm::x64::addr64::data32 should be used for x64
instructions whose default address and operand sizes are respectively 64-bit
and 32-bit. Currently we don't support other default address or operand size
 modes.

TODO:Add instructions for other compilers

1.3 Syntax

In general, the prototype of an instruction is in one of the following forms:

int MNEMONIC(uint8_t* p);
int MNEMONIC(uint8_t* p,OPERAND_TYPE op1);
int MNEMONIC(uint8_t* p,OPERAND_TYPE op1,OPERAND_TYPE op2);
int MNEMONIC(uint8_t* p,OPERAND_TYPE op1,OPERAND_TYPE op2,OPERAND_TYPE op3);

where uint8_t is most likely an alias of unsigned char.(see the documentation
of Boost stdint for the detail.) It is declared in erasm::x64 and
erasm::x86 namespaces.

Examples:
 p += adc  (p,word_ptr  [edx + esi * _2],ax);
 p += and_ (p,dword_ptr [rip + 0x1000],r12d);
 p += jmp  (p, 0x10);
 p += rep_movs (p,dword_ptr.es [di],dword_ptr.gs [si]);

 
The operational meaning of each instruction is always the same.That is,
it encodes the instruction at the location specified by the first argument(p),
and returns the number of bytes encoded.If the target address is writable,it
is guaranteed that either it succeeds to encode the instruction, or the 
instruction is syntactically ill-formed and the compilation fails.It is
undefined what would happen if the destination address is not writable.In
particular,it never throws a (C++) exception.

MNEMONIC is generally one of the instruction mnemonics as defined in the
Intel's Instruction Set Reference[2], converted to all lower-case letters.

There are some exceptions to this rule:
  * If the lower-case mnemonic is reserved as a keyword in C++ ,we append an
    underscore to the mnemonic, as in 'int_','xor_',etc.

  * If the instruction requires a mandatory prefix such as 'REP','REPZ' etc.,
    then the prefix and the mnemonic are joined by an underscore,as in 
    'repe_scas'.

  * Some instructions are ambiguous and cannot be fully specified solely by
    the combination of mnemonic and operand types. In such a case, we resort
    to some ad-hoc case-by-case disambiguation schemes such as:
  
    p +=      rep_movs(p,byte_ptr[rdi],byte_ptr[rsi]);
    p += rexw_rep_movs(p,byte_ptr[rdi],byte_ptr[rsi]);

    Here,rep_movs uses ecx as the count register,while rexw_rep_movs uses rcx.
    We are searching for less ad-hoc disambiguation methods,but we would also
    like the form of those instructions to be directly guessable from the
    Intel's manual.

OPERAND_TYPE is the type of an operand, which is generally what your common
sense as an assembly programmer tells you.More specifically,an operand is one
of the following objects:

 * Registers. dh,ax,edx,xmm0,st3,gs,rax,r8,r9b,sil,etc.

 * Memory references. 
     byte_ptr [esp + ebp * _2 + 4],
     dword_ptr [ebx * _8 + _4],
     xmmword_ptr . gs[bx+di].

 * Immediates. (int32_t)0,(int8_t)1,_1,_2,etc. The static constants _0 - _9
   can be used as a shorthand for specifying small 8-bit integers. By nature,
   assembly instructions are quite picky about the exact operand types, and
   it is very often the case that explicit casting is necessary to avoid
   ambiguity.

A caveat is that the scale coefficient of the index register 
(e.g. _2 of [edx + _2 * ecx]) must be specified with the static constants
_1-_9. This inconvenience results from the need to compute the necessary
data statically,and will not change.

Please see intel's Instruction Set Reference[2] for instruction definitions.

For the examples of valid instructions,see

  src/erasm/x64_assembler_manual_test.cpp
  src/erasm/x64_assembler_auto_test.cpp
  src/erasm/x86_assembler_manual_test.cpp
  src/erasm/x86_assembler_auto_test.cpp

For the examples of ill-formed instructions,see

  src/erasm/x64_assembler_illegal_code.cpp
  src/erasm/x86_assembler_illegal_code.cpp.


1.4 Performance

If all the required functions are inlined(see below),ERASM++ instructions 
will be compiled to a very fast and very localized code.

Let us give an example.

g++ 4.6.1 compiles (with the option -O3) the following code

<CODE>
inline int adc (code_ptr p, const ByteReg86 & op1,const BytePtr86 & op2)
{
   // if the required instruction definition is declared inline like this..
}

extern "C" int code_test(code_ptr p)
{ return adc(p ,cl,byte_ptr [eax+ebp*_4+12345678]);  }
</CODE>

to

<CODE>
_code_test:
	sub	esp, 32
	mov	eax, DWORD PTR [esp+36]
	mov	BYTE PTR [esp+5], -88
	mov	DWORD PTR [esp+6], 12345678
	mov	BYTE PTR [esp+4], -116
	mov	BYTE PTR [eax], 103
	mov	BYTE PTR [eax+1], 18
	mov	edx, DWORD PTR [esp+4]
	mov	DWORD PTR [eax+2], edx
	mov	edx, DWORD PTR [esp+8]
	mov	WORD PTR [eax+6], dx
	mov	eax, 8
	add	esp, 32
	ret
</CODE>


Although the above code may not be the fastest possible, we observe the
following very nice properties:

* No branches. 

Conditional or not,branches always consume precious processor resources[4],
so their absence is quite beneficial for performance reasons. Furthermore,in
kernel spaces,there is a greater risk that the target address is not
accessible at all (e.g. the corresponding section may have been swapped out
and the code runs in a high priority mode.)
 
* No external references.

This is also a very good property for the similar reasons. See [4] for the
details.

Although there are strong arguments against introducing C++ into the 
operating system kernel spaces[5][6], it should be clear that ERASM++ per se
does not possess any such weakness that makes it hard to adopt C++ code into
the kernel space.

Currently the main ERASM++ encoder functions are all compiled in a seperate
module for the sake of compile-time performance.See 
src/test_asm_performance.cpp for how to inline the required functions.

1.5 Limitations

By far the biggest limitation of ERASM++ is its compile-time resource usage.
For reasons explained later,the exact compile-time behaviour greatly varies
from one compiler version to another.

For example,while g++-4.5.4 compiles a source file which consists of about
2500 instructions just fine with memory usage ~500MB ,g++-4.6.1 consumes all 
its user-space (~2GB) and eventually gives up.

Another disadvantage of using ERASM++ is its often cryptic error messages.
This is inherently an implementation-dependant problem,and is impossible to 
solve generally.

Current implementation only makes some effort to increase readability for g++.

Here's an example (manually formatted) error message from g++:

<CODE>
cvtpd2pi(p,mm1,xmmword_ptr[rax+ rsp*_2]);
</CODE>
results to 

./erasm/meta_prelude_core.hpp:829:128: error: no type named 'result' in 
'struct erasm::prelude::eval<
   erasm::prelude::if_<
     erasm::prelude::error<
        erasm::x64::Error_ESP_and_RSP_cannot_be_used_as_the_index_register,
        erasm::prelude::Term<erasm::prelude::Int<4>, 
                             erasm::prelude::times<erasm::prelude::Int<2>, 
                                                   erasm::prelude::Int<1> > >,
        erasm::prelude::Term<erasm::prelude::Int<0>, erasm::prelude::Int<1> >,
        void, void>, 
     erasm::x64::PtrRex<erasm::x64::XmmWord>, 
     erasm::x64::PtrNoRex<erasm::x64::XmmWord> > >'

Note the 'Error_ESP_and_RSP_cannot_be_used_as_the_index_register' part above,
which correctly spots the problem.

Unfortunately,Microsoft's cl.exe tries to outsmart our effort and emits
more obscure error messages.

ERASM++ declares and uses static constants _1,_2,etc. in one of its
namespaces. This is potentially problematic as the standard specifies that 
any identifier that begins with an underscore is reserved for the
implementation in the global namespace.

Finally,ERASM++ cannot be fully standard conformant because it must be 
dependent on the platform-specific data representations.Howerver,if the 
implementation does support the platform, there should be no problem 
compiling ERASM++ as long as the compiler is reasonably standard-conformant.


2. License

ERASM++ is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

ERASM++ is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with ERASM++; see the file COPYING.  If not see
<http://www.gnu.org/licenses/>. 


Reference

[1] Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 1:
    Basic Architecture.
[2] Intel® 64 and IA-32 Architectures Software Developer's Manual Combined
    Volumes 2A, 2B, and 2C: Instruction Set Reference, A-Z.
[3] Intel® 64 and IA-32 Architectures Software Developer's Manual Combined
    Volumes 3A, 3B, and 3C: System Programming Guide, Parts 1 and 2.
[4] Intel® 64 and IA-32 Architectures Optimization Reference Manual.
[5] http://kerneltrap.org/node/2067 
[6] http://msdn.microsoft.com/en-us/windows/hardware/gg487420
